const utils = require('./utils.js');
const path = require('path');
const fs = require('fs');
const os = require('os')

let buildProcess; //Holds child_process object when running build

const assetPath = process.env.NODE_ENV === 'development'
    ? path.join(__dirname, '../../assets')
    : path.join(process.resourcesPath, 'assets');

/*
* Functions to run compilations/build process for each OS
*/

exports.cancelBuild = function() {
  try {
    process.kill(-buildProcess.pid);
  }
  catch (err) {
    console.log("Process is not active: ", err);
  }
}

exports.getChildProcess = function() {
  return buildProcess;
}

exports.buildGNU = function(project_path, config) {

  return new Promise(function(resolve, reject) {
    
    buildProcess = utils.spawnChild(
      "make",
      ["CONFIG=" + config, "AR=gcc-ar", "-j`nproc --ignore=2`"],
      {shell: true, cwd: project_path + "/Binaries/Builds/LinuxMakefile"}
    );
    
    buildProcess.on('close', code => {code == 0 ? resolve() : reject(code)});
    
  }).catch((err) => {console.log('Caught! ' + err)});
}

exports.buildInstallerGNU = function(project_path, project_name, project_version) {
  
  return new Promise(async function(resolve, reject) {
    
    try {
      const escape = require('escape-path-with-spaces');
      
      let makeself = '"' + assetPath + "/makeself/makeself.sh" + '"';
      let license = '"' + project_path + "/License.txt" + '"';
      let archive_dir = project_path + "/Packaging/" + process.platform;
      let file_name = archive_dir + "/" + project_name + "-" + project_version + ".run";
          
      //Copy license to packaging folder
      fs.copyFileSync(path.join(project_path, "License.txt"), path.join(archive_dir, "License.txt"));

      //Copy startup script to packaging folder
      fs.copyFileSync(path.join(assetPath, "gnu-setup-script.sh"), path.join(archive_dir, "gnu-setup-script.sh"));
      
      //Run makeself
      await utils.asyncExecFile(makeself, ["--license", license, '"' + archive_dir + '"', '"' + file_name + '"', '"' + project_name + '"', "./gnu-setup-script.sh"], {shell:true});
      
      resolve();
    }
    catch (err) {
      reject(err);
    }  
  }).catch((err) => {console.log('Caught! ' + err)});
}

exports.buildOSX = function(project_path, config) {
  
  return new Promise(function(resolve, reject) {
    
    let cwd = path.join(project_path, "Binaries", "Builds", "MacOSX");
    let threads = os.cpus().length * 2 - 2;

    buildProcess = utils.spawnChild(
      "xcodebuild",
      ["-project", "*.xcodeproj", "-configuration", config, "-jobs", threads],
      {shell: true, "cwd": cwd}
    );

    buildProcess.on('close', code => {code == 0 ? resolve() : reject(code)});
    
  }).catch((err) => {console.log('Caught! ' + err)});  
}


exports.buildInstallerOSX = function() {

   /*return new Promise(async function(resolve, reject) {
    
    try {      
      
      let packages = "/usr/local/bin/packagesbuild";
    
      let license = path.join(project_path, "License.txt");
      let archive_dir = project_path + "/Packaging/" + process.platform;
      let file_name = archive_dir + "/" + project_name + "-" + project_version + ".run";
          
      //Copy license to packaging folder
      fs.copyFileSync(path.join(project_path, "License.txt"), path.join(archive_dir, "License.txt"));

      //Copy startup script to packaging folder
      fs.copyFileSync(path.join(assetPath, "gnu-setup-script.sh"), path.join(archive_dir, "gnu-setup-script.sh"));
      
      //Run makeself
      await utils.asyncExecFile(makeself, ["--license", license, '"' + archive_dir + '"', '"' + file_name + '"', '"' + project_name + '"', "./gnu-setup-script.sh"], {shell:true});
      
      resolve();
    }
    catch (err) {
      reject(err);
    }  
  }).catch((err) => {console.log('Caught! ' + err)});*/
}

exports.buildWindows = function(type, format, arch) {
  /*
  @echo off
set project=Santur
set build_path=Y:\Strings\nuno_silva\santur\HISE\Binaries
set msbuild="C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\MsBuild.exe"
set vs_args=/p:Configuration="Release" /verbosity:minimal
set PreferredToolArchitecture=x64
set VisualStudioVersion=15.0

"Z:\tools\Projucer\Projucer.exe" --resave "%build_path%\AutogeneratedProject.jucer"

echo Compiling 64bit Standalone application %project% ...
set Platform=X64
%msbuild% "%build_path%\Builds\VisualStudio2017\%project%.sln" %vs_args%*/
  
}

//Assembles a new filename for the binary - without extension
exports.getNewFilename = function(project_path, project_name, build_args, config) {
  
  //Turn arguments into string to append to file name
  if (build_args.indexOf("-l") != -1) build_args[build_args.indexOf("-l")] = "-legacy"; //Expand -l to -legacy
  
  build_args.splice(0, 1) //Remove plugin type
  build_args.splice(-1, 1) //Remove project type

  //Remove unneeded chars
  build_args = build_args.map((x) => x.indexOf(":") != -1 ? "-" + x.substring(x.indexOf(":")+1) : x)

  if (config == "Release")
    return project_name + build_args.join("");
  else
    return project_name + build_args.join("") + "-Debug";
}

//Determines the extension of the binary file based on the build arguments
exports.getBinaryExtension = function(build_args) {
  
  let ext = "";
  if (build_args.includes("-p:VST3")) ext = ".vst3";
  if (build_args.includes("-p:AU")) ext = ".component";
  if (build_args.includes("-p:AAX")) ext = ".aaxplugin";
  
  switch (process.platform) {
    case "linux":
      if (build_args.includes("-p:VST")) ext = ".so";
    break;
    
    case "darwin":
      if (build_args.includes("-p:VST")) ext = ".vst";
      if (build_args.includes("-t:standalone")) ext = ".app";
    break;
    
    case "win32":
      if (build_args.includes("-p:VST")) ext = ".dll";
      if (build_args.includes("-t:standalone")) ext = ".exe";
    break;
  }
  
  return ext;
}

//Get location of binary file
exports.getOutputDirectory = function(config) {

  let result = path.join("Binaries", "Builds")

  switch (process.platform) {
    case "linux":
      return path.join(result, "LinuxMakefile", "build");
    break;
    
    case "darwin":
      return path.join(result, "MacOSX", "build", config);
    break;
    
    case "win32":
      return path.join(result, "VisualStudio2017");
    break;
  }
}

//Get name of generated binary file - without extension
exports.getOutputName = function(project_name, config) {
  
  switch (process.platform) {    
    case "darwin":
      return project_name + " " + config;
    break;
    
    case "win32":
      return project_name + "_" + config;
    break;
  }
}

/*
* Wrappers for HISE CLI commands
*/
exports.setHISEFolder = function(hise, hise_source) {
  return utils.asyncExec('"' + hise + '"', ["set_hise_folder", "-p:" + '"' + hise_source + '"']);
}

exports.setProjectFolder = function(hise, project_path) {
  return utils.asyncExec('"' + hise + '"', ["set_project_folder", "-p:" + '"' + project_path + '"']);
}

exports.setProjectVersion = function(hise, project_version) {
  return utils.asyncExec('"' + hise + '"', ["set_version", "-v:" + project_version]);
}

exports.cleanBuildDirectory = function(hise, project_path) {
  return utils.asyncExec('"' + hise + '"', ["clean", "-p:" + project_path, "--all"]);
}

exports.runHISEExport = function(hise, project_path, project_file, extraArgs) {
  //let path = '"' + project_path + "/XmlPresetBackups/" + project_file + '"'; --Works on GNU
  let project = path.join(project_path, "XmlPresetBackups", project_file);
  extraArgs = extraArgs.join(" ");
  return utils.asyncExec('"' + hise + '"', ["export_ci", project, extraArgs]);
}

//Resaves the AutogeneratedProject.jucer file
exports.resaveJucerFile = function(hise_source, project_path) {
  //let projucer = '"' + hise_source + "/tools/projucer/Projucer" + '"';// --Works on GNU
  let projucer = path.join(hise_source, "tools", "projucer", "Projucer"); 
  let cwd = path.join(project_path, "Binaries");
  
  //Append extension on Windows
  if (process.platform == "win32")
    projucer += ".exe";
  
  //Append additional file path on MacOS
  if (process.platform == "darwin")
    projucer = path.join(projucer + ".app", "Contents", "MacOS", "Projucer");
    
  //Add executable permissions to Projucer binary (might not work on Windows)
  fs.chmodSync(projucer, 0o775);
   
  return utils.asyncExec(projucer, ["--resave AutogeneratedProject.jucer"], {"shell": true, "cwd": cwd});
}

//Creates directory to store compiled binaries
exports.createPackagingDirectory = function(project_path) {
  let packaging = '"' + project_path + "/Packaging/" + process.platform + '"';
  return utils.asyncExec("mkdir", ["-p", packaging]);
}